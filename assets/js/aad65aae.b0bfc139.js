"use strict";(self.webpackChunkalgorithm_essentials=self.webpackChunkalgorithm_essentials||[]).push([[8819],{97321:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"bfs/graph/word-ladder-ii","title":"Word Ladder II","description":"\u63cf\u8ff0","source":"@site/docs/bfs/graph/word-ladder-ii.md","sourceDirName":"bfs/graph","slug":"/bfs/graph/word-ladder-ii","permalink":"/bfs/graph/word-ladder-ii","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Word Ladder II"},"sidebar":"docs","previous":{"title":"Word Ladder","permalink":"/bfs/graph/word-ladder"},"next":{"title":"Surrounded Regions","permalink":"/bfs/graph/surrounded-regions"}}');var s=e(74848),a=e(28453),i=e(11470),o=e(19365);const l={title:"Word Ladder II"},d=void 0,u={},c=[{value:"\u63cf\u8ff0",id:"\u63cf\u8ff0",level:3},{value:"\u5206\u6790",id:"\u5206\u6790",level:3},{value:"\u5355\u961f\u5217",id:"\u5355\u961f\u5217",level:3},{value:"\u53cc\u961f\u5217",id:"\u53cc\u961f\u5217",level:3},{value:"\u56fe\u7684\u5e7f\u641c",id:"\u56fe\u7684\u5e7f\u641c",level:3},{value:"\u76f8\u5173\u9898\u76ee",id:"\u76f8\u5173\u9898\u76ee",level:3}];function h(t){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"\u63cf\u8ff0",children:"\u63cf\u8ff0"}),"\n",(0,s.jsx)(n.p,{children:"Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only one letter can be changed at a time"}),"\n",(0,s.jsx)(n.li,{children:"Each intermediate word must exist in the dictionary"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For example, Given:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'start = "hit"\nend = "cog"\ndict = ["hot","dot","dog","lot","log"]\n'})}),"\n",(0,s.jsx)(n.p,{children:"Return"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'[\n    ["hit","hot","dot","dog","cog"],\n    ["hit","hot","lot","log","cog"]\n]\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"All words have the same length."}),"\n",(0,s.jsx)(n.li,{children:"All words contain only lowercase alphabetic characters."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"\u5206\u6790",children:"\u5206\u6790"}),"\n",(0,s.jsx)(n.p,{children:"\u8ddf Word Ladder \u6bd4\uff0c\u8fd9\u9898\u662f\u6c42\u8def\u5f84\u672c\u8eab\uff0c\u4e0d\u662f\u8def\u5f84\u957f\u5ea6\uff0c\u4e5f\u662f BFS\uff0c\u7565\u5fae\u9ebb\u70e6\u70b9\u3002"}),"\n",(0,s.jsx)(n.p,{children:"\u6c42\u4e00\u6761\u8def\u5f84\u548c\u6c42\u6240\u6709\u8def\u5f84\u6709\u5f88\u5927\u7684\u4e0d\u540c\uff0c\u6c42\u4e00\u6761\u8def\u5f84\uff0c\u6bcf\u4e2a\u72b6\u6001\u8282\u70b9\u53ea\u9700\u8981\u8bb0\u5f55\u4e00\u4e2a\u524d\u9a71\u5373\u53ef\uff1b\u6c42\u6240\u6709\u8def\u5f84\u65f6\uff0c\u6709\u7684\u72b6\u6001\u8282\u70b9\u53ef\u80fd\u6709\u591a\u4e2a\u7236\u8282\u70b9\uff0c\u5373\u8981\u8bb0\u5f55\u591a\u4e2a\u524d\u9a71\u3002"}),"\n",(0,s.jsx)(n.p,{children:"\u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\u3002"}),"\n",(0,s.jsx)(n.h3,{id:"\u5355\u961f\u5217",children:"\u5355\u961f\u5217"}),"\n","\n",(0,s.jsxs)(i.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],children:[(0,s.jsx)(o.A,{value:"java",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        Queue<String> q = new LinkedList<>();\n        HashMap<String, Integer> visited = new HashMap<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n                    final int newDepth = visited.get(s) + 1;\n\n                    if (stateIsValid.apply(newState)) {\n                        if (visited.containsKey(newState)) {\n                            final int depth = visited.get(newState);\n                            if (depth < newDepth) {\n                                // do nothing\n                            } else if (depth == newDepth) {\n                                result.add(newState);\n                            } else {\n                                throw new IllegalStateException(\"not possible to get here\");\n                            }\n\n                        } else {\n                            result.add(newState);\n                        }\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        q.offer(beginWord);\n        visited.put(beginWord, 0);\n        while (!q.isEmpty()) {\n            String state = q.poll();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && (visited.get(state) + 1) > result.get(0).size()) break;\n\n            if (stateIsTarget.apply(state)) {\n                ArrayList<String> path = new ArrayList<>();\n                genPath(father, beginWord, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            HashSet<String> newStates = stateExtend.apply(state);\n            for (String newState : newStates) {\n                if (!visited.containsKey(newState)) {\n                    q.offer(newState);\n                    visited.put(newState, visited.get(state)+1);\n                }\n                ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                parents.add(state);\n                father.put(newState, parents);\n            }\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}\n"})})}),(0,s.jsx)(o.A,{value:"cpp",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n        const string& end, const unordered_set<string> &dict) {\n        queue<string> q;\n        unordered_map<string, int> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end; };\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n            const int new_depth = visited[s] + 1;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_state = s;\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_state[i]) continue;\n\n                    swap(c, new_state[i]);\n\n                    if (state_is_valid(new_state)) {\n                        auto visited_iter = visited.find(new_state);\n\n                        if (visited_iter != visited.end()) {\n                            const int depth = visited_iter->second;\n                            if (depth < new_depth) {\n                                // do nothing\n                            }\n                            else if (depth == new_depth) {\n                                result.insert(new_state);\n                            }\n                            else { // not possible\n                                throw std::logic_error(\"not possible to get here\");\n                            }\n                        }\n                        else {\n                            result.insert(new_state);\n                        }\n                    }\n                    swap(c, new_state[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string>> result;\n        q.push(start);\n        visited[start] = 0;\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && visited[state] + 1 > result[0].size()) break;\n\n            if (state_is_target(state)) {\n                vector<string> path;\n                gen_path(father, start, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                if (visited.find(new_state) == visited.end()) {\n                    q.push(new_state);\n                    visited[new_state] = visited[state] + 1;\n                }\n                father[new_state].push_back(state);\n            }\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n        const string &start, const string &state, vector<string> &path,\n        vector<vector<string> > &result) {\n        path.push_back(state);\n        if (state == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                }\n                else if (path.size() == result[0].size()) {\n                    // do nothing\n                }\n                else { // not possible\n                    throw std::logic_error(\"not possible to get here \");\n                }\n            }\n            result.push_back(path);\n            reverse(result.back().begin(), result.back().end());\n        }\n        else {\n            for (const auto& f : father[state]) {\n                gen_path(father, start, f, path, result);\n            }\n        }\n        path.pop_back();\n    }\n};\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"\u53cc\u961f\u5217",children:"\u53cc\u961f\u5217"}),"\n",(0,s.jsxs)(i.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],children:[(0,s.jsx)(o.A,{value:"java",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        // \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        // \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        HashSet<String> current = new HashSet<>();\n        HashSet<String> next = new HashSet<>();\n        HashSet<String> visited = new HashSet<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n        int level = -1; // \u5c42\u6b21\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n\n                    if (stateIsValid.apply(newState) &&\n                            !visited.contains(newState)) {\n                        result.add(newState);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        current.add(beginWord);\n        while (!current.isEmpty()) {\n            ++ level;\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && level + 1 > result.get(0).size()) break;\n\n            // 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            // 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            // \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            for (String state : current)\n                visited.add(state);\n\n            for (String state : current) {\n                if (stateIsTarget.apply(state)) {\n                    ArrayList<String> path = new ArrayList<>();\n                    genPath(father, beginWord, state, path, result);\n                    continue;\n                }\n                // \u6269\u5c55\u8282\u70b9\n                HashSet<String> newStates = stateExtend.apply(state);\n                for (String newState : newStates) {\n                    next.add(newState);\n                    ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                    parents.add(state);\n                    father.put(newState, parents);\n                }\n            }\n            current.clear();\n            // swap\n            HashSet<String> tmp = current;\n            current = next;\n            next = tmp;\n\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}\n"})})}),(0,s.jsx)(o.A,{value:"cpp",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n            const string& end, const unordered_set<string> &dict) {\n        // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        // \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        // \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        unordered_set<string> current, next;\n        unordered_set<string> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n\n        int level = -1;  // \u5c42\u6b21\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end;};\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_word(s);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if (state_is_valid(new_word) &&\n                            visited.find(new_word) == visited.end()) {\n                        result.insert(new_word);\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string> > result;\n        current.insert(start);\n        while (!current.empty()) {\n            ++ level;\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\n            // \u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && level+1 > result[0].size()) break;\n\n            // 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            // 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            // \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            for (const auto& state : current)\n                visited.insert(state);\n            for (const auto& state : current) {\n                if (state_is_target(state)) {\n                    vector<string> path;\n                    gen_path(father, path, start, state, result);\n                    continue;\n                }\n\n                const auto new_states = state_extend(state);\n                for (const auto& new_state : new_states) {\n                    next.insert(new_state);\n                    father[new_state].push_back(state);\n                }\n            }\n\n            current.clear();\n            swap(current, next);\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n            vector<string> &path, const string &start, const string &word,\n            vector<vector<string> > &result) {\n        path.push_back(word);\n        if (word == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                    result.push_back(path);\n                } else if(path.size() == result[0].size()) {\n                    result.push_back(path);\n                } else {\n                    // not possible\n                    throw std::logic_error(\"not possible to get here\");\n                }\n            } else {\n                result.push_back(path);\n            }\n            reverse(result.back().begin(), result.back().end());\n        } else {\n            for (const auto& f : father[word]) {\n                gen_path(father, path, start, f, result);\n            }\n        }\n        path.pop_back();\n    }\n};\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"\u56fe\u7684\u5e7f\u641c",children:"\u56fe\u7684\u5e7f\u641c"}),"\n",(0,s.jsxs)(n.p,{children:["\u524d\u9762\u7684\u89e3\u6cd5\uff0c\u5728\u72b6\u6001\u6269\u5c55\u7684\u65f6\u5019\uff0c\u6bcf\u6b21\u90fd\u662f\u4ece'a'\u5230'z'\u5168\u90e8\u679a\u4e3e\u4e00\u904d\uff0c\u91cd\u590d\u8ba1\u7b97\uff0c\u6bd4\u8f83\u6d6a\u8d39\uff0c\u5176\u5b9e\u5f53\u7ed9\u5b9a\u5b57\u5178",(0,s.jsx)(n.code,{children:"dict"}),"\u540e\uff0c\u5355\u8bcd\u4e0e\u5355\u8bcd\u4e4b\u95f4\u7684\u8def\u5f84\u5c31\u56fa\u5b9a\u4e0b\u6765\u4e86\uff0c\u672c\u8d28\u4e0a\u5355\u8bcd\u4e0e\u5355\u8bcd\u4e4b\u95f4\u6784\u6210\u4e86\u4e00\u4e2a\u65e0\u5411\u56fe\u3002\u5982\u679c\u4e8b\u5148\u628a\u8fd9\u4e2a\u56fe\u6784\u5efa\u51fa\u6765\uff0c\u90a3\u4e48\u72b6\u6001\u6269\u5c55\u5c31\u4f1a\u5927\u5927\u52a0\u5feb\u3002"]}),"\n",(0,s.jsxs)(i.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],children:[(0,s.jsx)(o.A,{value:"java",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Function;\n\n// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        Queue<String> q = new LinkedList<>();\n        HashMap<String, Integer> visited = new HashMap<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n        // only used by stateExtend()\n        final HashMap<String, HashSet<String>> g = buildGraph(wordList);\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, List<String> > stateExtend = (String s) -> {\n            List<String> result = new ArrayList<>();\n            final int newDepth = visited.get(s) + 1;\n            HashSet<String> list = g.get(s);\n            if (list == null) return result;\n\n            for (String newState : list) {\n                if (stateIsValid.apply(newState)) {\n                    if (visited.containsKey(newState)) {\n                        final int depth = visited.get(newState);\n                        if (depth < newDepth) {\n                            // do nothing\n                        } else if (depth == newDepth) {\n                            result.add(newState);\n                        } else {\n                            throw new IllegalStateException(\"not possible to get here\");\n                        }\n\n                    } else {\n                        result.add(newState);\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        q.offer(beginWord);\n        visited.put(beginWord, 0);\n        while (!q.isEmpty()) {\n            String state = q.poll();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && (visited.get(state) + 1) > result.get(0).size()) break;\n\n            if (stateIsTarget.apply(state)) {\n                ArrayList<String> path = new ArrayList<>();\n                genPath(father, beginWord, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            List<String> newStates = stateExtend.apply(state);\n            for (String newState : newStates) {\n                if (!visited.containsKey(newState)) {\n                    q.offer(newState);\n                    visited.put(newState, visited.get(state)+1);\n                }\n                ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                parents.add(state);\n                father.put(newState, parents);\n            }\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n\n    private static HashMap<String, HashSet<String>> buildGraph(Set<String> dict) {\n        HashMap<String, HashSet<String>> adjacency_list = new HashMap<>();\n        for (String word: dict) {\n            char[] array = word.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newWord = new String(array);\n\n                    if (dict.contains(newWord)) {\n                        HashSet<String> list = adjacency_list.getOrDefault(\n                                word, new HashSet<>());\n                        list.add(newWord);\n                        adjacency_list.put(word, list);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n        }\n        return adjacency_list;\n    }\n}\n"})})}),(0,s.jsx)(o.A,{value:"cpp",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n        const string& end, const unordered_set<string> &dict) {\n        queue<string> q;\n        unordered_map<string, int> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n        // only used by state_extend()\n        const unordered_map<string, unordered_set<string> >& g = build_graph(dict);\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end; };\n        auto state_extend = [&](const string &s) {\n            vector<string> result;\n            const int new_depth = visited[s] + 1;\n            auto iter = g.find(s);\n            if (iter == g.end()) return result;\n            const auto& list = iter->second;\n\n            for (const auto& new_state : list) {\n                if (state_is_valid(new_state)) {\n                    auto visited_iter = visited.find(new_state);\n                    if (visited_iter != visited.end()) {\n                        const int depth = visited_iter->second;\n                        if (depth < new_depth) {\n                            // do nothing\n                        }\n                        else if (depth == new_depth) {\n                            result.push_back(new_state);\n                        } else { // not possible\n                            throw std::logic_error(\"not possible to get here\");\n                        }\n                    }\n                    else {\n                        result.push_back(new_state);\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string>> result;\n        q.push(start);\n        visited[start] = 0;\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && visited[state] + 1 > result[0].size()) break;\n\n            if (state_is_target(state)) {\n                vector<string> path;\n                gen_path(father, start, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                if (visited.find(new_state) == visited.end()) {\n                    q.push(new_state);\n                    visited[new_state] = visited[state] + 1;\n                }\n                father[new_state].push_back(state);\n            }\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n        const string &start, const string &state, vector<string> &path,\n        vector<vector<string> > &result) {\n        path.push_back(state);\n        if (state == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                }\n                else if (path.size() == result[0].size()) {\n                    // do nothing\n                }\n                else { // not possible\n                    throw std::logic_error(\"not possible to get here \");\n                }\n            }\n            result.push_back(path);\n            reverse(result.back().begin(), result.back().end());\n        }\n        else {\n            for (const auto& f : father[state]) {\n                gen_path(father, start, f, path, result);\n            }\n        }\n        path.pop_back();\n    }\n    unordered_map<string, unordered_set<string> > build_graph(\n        const unordered_set<string>& dict) {\n        unordered_map<string, unordered_set<string> > adjacency_list;\n\n        for (const auto& word : dict) {\n            for (size_t i = 0; i < word.size(); ++i) {\n                string new_word(word);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if ((dict.find(new_word) != dict.end())) {\n                        auto iter = adjacency_list.find(word);\n                        if (iter != adjacency_list.end()) {\n                            iter->second.insert(new_word);\n                        }\n                        else {\n                            adjacency_list.insert(pair<string,\n                                unordered_set<string >> (word, unordered_set<string>()));\n                            adjacency_list[word].insert(new_word);\n                        }\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n        }\n        return adjacency_list;\n    }\n};\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"\u76f8\u5173\u9898\u76ee",children:"\u76f8\u5173\u9898\u76ee"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/bfs/graph/word-ladder",children:"Word Ladder"})}),"\n"]})]})}function p(t={}){const{wrapper:n}={...(0,a.R)(),...t.components};return n?(0,s.jsx)(n,{...t,children:(0,s.jsx)(h,{...t})}):h(t)}},19365:(t,n,e)=>{e.d(n,{A:()=>i});e(96540);var r=e(34164);const s={tabItem:"tabItem_Ymn6"};var a=e(74848);function i(t){let{children:n,hidden:e,className:i}=t;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,i),hidden:e,children:n})}},11470:(t,n,e)=>{e.d(n,{A:()=>m});var r=e(96540),s=e(34164),a=e(23104),i=e(56347),o=e(205),l=e(57485),d=e(31682),u=e(70679);function c(t){return r.Children.toArray(t).filter((t=>"\n"!==t)).map((t=>{if(!t||(0,r.isValidElement)(t)&&function(t){const{props:n}=t;return!!n&&"object"==typeof n&&"value"in n}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(t){const{values:n,children:e}=t;return(0,r.useMemo)((()=>{const t=n??function(t){return c(t).map((t=>{let{props:{value:n,label:e,attributes:r,default:s}}=t;return{value:n,label:e,attributes:r,default:s}}))}(e);return function(t){const n=(0,d.XI)(t,((t,n)=>t.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[n,e])}function p(t){let{value:n,tabValues:e}=t;return e.some((t=>t.value===n))}function g(t){let{queryString:n=!1,groupId:e}=t;const s=(0,i.W6)(),a=function(t){let{queryString:n=!1,groupId:e}=t;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,l.aZ)(a),(0,r.useCallback)((t=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,t),s.replace({...s.location,search:n.toString()})}),[a,s])]}function f(t){const{defaultValue:n,queryString:e=!1,groupId:s}=t,a=h(t),[i,l]=(0,r.useState)((()=>function(t){let{defaultValue:n,tabValues:e}=t;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=e.find((t=>t.default))??e[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:a}))),[d,c]=g({queryString:e,groupId:s}),[f,w]=function(t){let{groupId:n}=t;const e=function(t){return t?`docusaurus.tab.${t}`:null}(n),[s,a]=(0,u.Dv)(e);return[s,(0,r.useCallback)((t=>{e&&a.set(t)}),[e,a])]}({groupId:s}),v=(()=>{const t=d??f;return p({value:t,tabValues:a})?t:null})();(0,o.A)((()=>{v&&l(v)}),[v]);return{selectedValue:i,selectValue:(0,r.useCallback)((t=>{if(!p({value:t,tabValues:a}))throw new Error(`Can't select invalid tab value=${t}`);l(t),c(t),w(t)}),[c,w,a]),tabValues:a}}var w=e(92303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var S=e(74848);function _(t){let{className:n,block:e,selectedValue:r,selectValue:i,tabValues:o}=t;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,a.a_)(),u=t=>{const n=t.currentTarget,e=l.indexOf(n),s=o[e].value;s!==r&&(d(n),i(s))},c=t=>{let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=l.indexOf(t.currentTarget)+1;n=l[e]??l[0];break}case"ArrowLeft":{const e=l.indexOf(t.currentTarget)-1;n=l[e]??l[l.length-1];break}}n?.focus()};return(0,S.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":e},n),children:o.map((t=>{let{value:n,label:e,attributes:a}=t;return(0,S.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:t=>l.push(t),onKeyDown:c,onClick:u,...a,className:(0,s.A)("tabs__item",v.tabItem,a?.className,{"tabs__item--active":r===n}),children:e??n},n)}))})}function b(t){let{lazy:n,children:e,selectedValue:a}=t;const i=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const t=i.find((t=>t.props.value===a));return t?(0,r.cloneElement)(t,{className:(0,s.A)("margin-top--md",t.props.className)}):null}return(0,S.jsx)("div",{className:"margin-top--md",children:i.map(((t,n)=>(0,r.cloneElement)(t,{key:n,hidden:t.props.value!==a})))})}function y(t){const n=f(t);return(0,S.jsxs)("div",{className:(0,s.A)("tabs-container",v.tabList),children:[(0,S.jsx)(_,{...n,...t}),(0,S.jsx)(b,{...n,...t})]})}function m(t){const n=(0,w.A)();return(0,S.jsx)(y,{...t,children:c(t.children)},String(n))}},28453:(t,n,e)=>{e.d(n,{R:()=>i,x:()=>o});var r=e(96540);const s={},a=r.createContext(s);function i(t){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function o(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(s):t.components||s:i(t.components),r.createElement(a.Provider,{value:n},t.children)}}}]);