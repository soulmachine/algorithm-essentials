"use strict";(self.webpackChunkalgorithm_essentials=self.webpackChunkalgorithm_essentials||[]).push([[8819],{97321:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>d,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"bfs/graph/word-ladder-ii","title":"Word Ladder II","description":"\u63cf\u8ff0","source":"@site/docs/bfs/graph/word-ladder-ii.md","sourceDirName":"bfs/graph","slug":"/bfs/graph/word-ladder-ii","permalink":"/en/bfs/graph/word-ladder-ii","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Word Ladder II"},"sidebar":"docs","previous":{"title":"Word Ladder","permalink":"/en/bfs/graph/word-ladder"},"next":{"title":"Surrounded Regions","permalink":"/en/bfs/graph/surrounded-regions"}}');var s=e(74848),a=e(28453),i=e(11470),l=e(19365);const d={title:"Word Ladder II"},o=void 0,u={},c=[{value:"\u63cf\u8ff0",id:"\u63cf\u8ff0",level:3},{value:"\u5206\u6790",id:"\u5206\u6790",level:3},{value:"\u5355\u961f\u5217",id:"\u5355\u961f\u5217",level:3},{value:"\u53cc\u961f\u5217",id:"\u53cc\u961f\u5217",level:3},{value:"\u56fe\u7684\u5e7f\u641c",id:"\u56fe\u7684\u5e7f\u641c",level:3},{value:"\u76f8\u5173\u9898\u76ee",id:"\u76f8\u5173\u9898\u76ee",level:3}];function h(n){const t={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h3,{id:"\u63cf\u8ff0",children:"\u63cf\u8ff0"}),"\n",(0,s.jsx)(t.p,{children:"Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Only one letter can be changed at a time"}),"\n",(0,s.jsx)(t.li,{children:"Each intermediate word must exist in the dictionary"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"For example, Given:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'start = "hit"\nend = "cog"\ndict = ["hot","dot","dog","lot","log"]\n'})}),"\n",(0,s.jsx)(t.p,{children:"Return"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:'[\n    ["hit","hot","dot","dog","cog"],\n    ["hit","hot","lot","log","cog"]\n]\n'})}),"\n",(0,s.jsx)(t.p,{children:"Note:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"All words have the same length."}),"\n",(0,s.jsx)(t.li,{children:"All words contain only lowercase alphabetic characters."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"\u5206\u6790",children:"\u5206\u6790"}),"\n",(0,s.jsx)(t.p,{children:"\u8ddf Word Ladder \u6bd4\uff0c\u8fd9\u9898\u662f\u6c42\u8def\u5f84\u672c\u8eab\uff0c\u4e0d\u662f\u8def\u5f84\u957f\u5ea6\uff0c\u4e5f\u662f BFS\uff0c\u7565\u5fae\u9ebb\u70e6\u70b9\u3002"}),"\n",(0,s.jsx)(t.p,{children:"\u6c42\u4e00\u6761\u8def\u5f84\u548c\u6c42\u6240\u6709\u8def\u5f84\u6709\u5f88\u5927\u7684\u4e0d\u540c\uff0c\u6c42\u4e00\u6761\u8def\u5f84\uff0c\u6bcf\u4e2a\u72b6\u6001\u8282\u70b9\u53ea\u9700\u8981\u8bb0\u5f55\u4e00\u4e2a\u524d\u9a71\u5373\u53ef\uff1b\u6c42\u6240\u6709\u8def\u5f84\u65f6\uff0c\u6709\u7684\u72b6\u6001\u8282\u70b9\u53ef\u80fd\u6709\u591a\u4e2a\u7236\u8282\u70b9\uff0c\u5373\u8981\u8bb0\u5f55\u591a\u4e2a\u524d\u9a71\u3002"}),"\n",(0,s.jsx)(t.p,{children:"\u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\u3002"}),"\n",(0,s.jsx)(t.h3,{id:"\u5355\u961f\u5217",children:"\u5355\u961f\u5217"}),"\n","\n",(0,s.jsxs)(i.A,{defaultValue:"python",values:[{label:"Python",value:"python"},{label:"Java",value:"java"},{label:"C++",value:"cpp"}],children:[(0,s.jsx)(l.A,{value:"java",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        Queue<String> q = new LinkedList<>();\n        HashMap<String, Integer> visited = new HashMap<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n                    final int newDepth = visited.get(s) + 1;\n\n                    if (stateIsValid.apply(newState)) {\n                        if (visited.containsKey(newState)) {\n                            final int depth = visited.get(newState);\n                            if (depth < newDepth) {\n                                // do nothing\n                            } else if (depth == newDepth) {\n                                result.add(newState);\n                            } else {\n                                throw new IllegalStateException(\"not possible to get here\");\n                            }\n\n                        } else {\n                            result.add(newState);\n                        }\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        q.offer(beginWord);\n        visited.put(beginWord, 0);\n        while (!q.isEmpty()) {\n            String state = q.poll();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && (visited.get(state) + 1) > result.get(0).size()) break;\n\n            if (stateIsTarget.apply(state)) {\n                ArrayList<String> path = new ArrayList<>();\n                genPath(father, beginWord, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            HashSet<String> newStates = stateExtend.apply(state);\n            for (String newState : newStates) {\n                if (!visited.containsKey(newState)) {\n                    q.offer(newState);\n                    visited.put(newState, visited.get(state)+1);\n                }\n                ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                parents.add(state);\n                father.put(newState, parents);\n            }\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}\n"})})}),(0,s.jsx)(l.A,{value:"cpp",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n        const string& end, const unordered_set<string> &dict) {\n        queue<string> q;\n        unordered_map<string, int> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end; };\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n            const int new_depth = visited[s] + 1;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_state = s;\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_state[i]) continue;\n\n                    swap(c, new_state[i]);\n\n                    if (state_is_valid(new_state)) {\n                        auto visited_iter = visited.find(new_state);\n\n                        if (visited_iter != visited.end()) {\n                            const int depth = visited_iter->second;\n                            if (depth < new_depth) {\n                                // do nothing\n                            }\n                            else if (depth == new_depth) {\n                                result.insert(new_state);\n                            }\n                            else { // not possible\n                                throw std::logic_error(\"not possible to get here\");\n                            }\n                        }\n                        else {\n                            result.insert(new_state);\n                        }\n                    }\n                    swap(c, new_state[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string>> result;\n        q.push(start);\n        visited[start] = 0;\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && visited[state] + 1 > result[0].size()) break;\n\n            if (state_is_target(state)) {\n                vector<string> path;\n                gen_path(father, start, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                if (visited.find(new_state) == visited.end()) {\n                    q.push(new_state);\n                    visited[new_state] = visited[state] + 1;\n                }\n                father[new_state].push_back(state);\n            }\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n        const string &start, const string &state, vector<string> &path,\n        vector<vector<string> > &result) {\n        path.push_back(state);\n        if (state == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                }\n                else if (path.size() == result[0].size()) {\n                    // do nothing\n                }\n                else { // not possible\n                    throw std::logic_error(\"not possible to get here \");\n                }\n            }\n            result.push_back(path);\n            reverse(result.back().begin(), result.back().end());\n        }\n        else {\n            for (const auto& f : father[state]) {\n                gen_path(father, start, f, path, result);\n            }\n        }\n        path.pop_back();\n    }\n};\n"})})}),(0,s.jsx)(l.A,{value:"python",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Word Ladder II\n# \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nfrom collections import deque, defaultdict\nfrom typing import List, Set, Dict\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: Set[str]) -> List[List[str]]:\n        q = deque()\n        visited = {}  # \u5224\u91cd\n        father = defaultdict(list)  # DAG\n\n        def stateIsValid(s: str) -> bool:\n            return s in wordList or s == endWord\n\n        def stateIsTarget(s: str) -> bool:\n            return s == endWord\n\n        def stateExtend(s: str) -> set:\n            result = set()\n            array = list(s)\n            for i in range(len(array)):\n                old = array[i]\n                for c in range(ord('a'), ord('z') + 1):\n                    # \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if chr(c) == array[i]:\n                        continue\n\n                    array[i] = chr(c)\n                    newState = ''.join(array)\n                    newDepth = visited[s] + 1\n\n                    if stateIsValid(newState):\n                        if newState in visited:\n                            depth = visited[newState]\n                            if depth < newDepth:\n                                # do nothing\n                                pass\n                            elif depth == newDepth:\n                                result.add(newState)\n                            else:\n                                raise ValueError(\"not possible to get here\")\n                        else:\n                            result.add(newState)\n                    array[i] = old  # \u6062\u590d\u8be5\u5355\u8bcd\n            return result\n\n        def genPath(father: Dict[str, List[str]], start: str, state: str, path: List[str], result: List[List[str]]):\n            path.append(state)\n            if state == start:\n                if result:\n                    if len(path) < len(result[0]):\n                        result.clear()\n                    elif len(path) == len(result[0]):\n                        # do nothing\n                        pass\n                    else:\n                        raise ValueError(\"not possible to get here\")\n                tmp = path[::-1]\n                result.append(tmp)\n            else:\n                for f in father[state]:\n                    genPath(father, start, f, path, result)\n            path.pop()\n\n        result = []\n        q.append(beginWord)\n        visited[beginWord] = 0\n        while q:\n            state = q.popleft()\n\n            # \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            # \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if result and (visited[state] + 1) > len(result[0]):\n                break\n\n            if stateIsTarget(state):\n                genPath(father, beginWord, state, [], result)\n                continue\n\n            # \u6269\u5c55\u8282\u70b9\n            newStates = stateExtend(state)\n            for newState in newStates:\n                if newState not in visited:\n                    q.append(newState)\n                    visited[newState] = visited[state] + 1\n                father[newState].append(state)\n\n        return result\n"})})})]}),"\n",(0,s.jsx)(t.h3,{id:"\u53cc\u961f\u5217",children:"\u53cc\u961f\u5217"}),"\n",(0,s.jsxs)(i.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],children:[(0,s.jsx)(l.A,{value:"java",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        // \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        // \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        HashSet<String> current = new HashSet<>();\n        HashSet<String> next = new HashSet<>();\n        HashSet<String> visited = new HashSet<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n        int level = -1; // \u5c42\u6b21\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n\n                    if (stateIsValid.apply(newState) &&\n                            !visited.contains(newState)) {\n                        result.add(newState);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        current.add(beginWord);\n        while (!current.isEmpty()) {\n            ++ level;\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && level + 1 > result.get(0).size()) break;\n\n            // 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            // 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            // \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            for (String state : current)\n                visited.add(state);\n\n            for (String state : current) {\n                if (stateIsTarget.apply(state)) {\n                    ArrayList<String> path = new ArrayList<>();\n                    genPath(father, beginWord, state, path, result);\n                    continue;\n                }\n                // \u6269\u5c55\u8282\u70b9\n                HashSet<String> newStates = stateExtend.apply(state);\n                for (String newState : newStates) {\n                    next.add(newState);\n                    ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                    parents.add(state);\n                    father.put(newState, parents);\n                }\n            }\n            current.clear();\n            // swap\n            HashSet<String> tmp = current;\n            current = next;\n            next = tmp;\n\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}\n"})})}),(0,s.jsx)(l.A,{value:"cpp",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n            const string& end, const unordered_set<string> &dict) {\n        // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        // \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        // \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        unordered_set<string> current, next;\n        unordered_set<string> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n\n        int level = -1;  // \u5c42\u6b21\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end;};\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_word(s);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if (state_is_valid(new_word) &&\n                            visited.find(new_word) == visited.end()) {\n                        result.insert(new_word);\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string> > result;\n        current.insert(start);\n        while (!current.empty()) {\n            ++ level;\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\n            // \u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && level+1 > result[0].size()) break;\n\n            // 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            // 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            // \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            for (const auto& state : current)\n                visited.insert(state);\n            for (const auto& state : current) {\n                if (state_is_target(state)) {\n                    vector<string> path;\n                    gen_path(father, path, start, state, result);\n                    continue;\n                }\n\n                const auto new_states = state_extend(state);\n                for (const auto& new_state : new_states) {\n                    next.insert(new_state);\n                    father[new_state].push_back(state);\n                }\n            }\n\n            current.clear();\n            swap(current, next);\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n            vector<string> &path, const string &start, const string &word,\n            vector<vector<string> > &result) {\n        path.push_back(word);\n        if (word == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                    result.push_back(path);\n                } else if(path.size() == result[0].size()) {\n                    result.push_back(path);\n                } else {\n                    // not possible\n                    throw std::logic_error(\"not possible to get here\");\n                }\n            } else {\n                result.push_back(path);\n            }\n            reverse(result.back().begin(), result.back().end());\n        } else {\n            for (const auto& f : father[word]) {\n                gen_path(father, path, start, f, result);\n            }\n        }\n        path.pop_back();\n    }\n};\n"})})}),(0,s.jsx)(l.A,{value:"python",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Word Ladder II\n# \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: set) -> list[list[str]]:\n        # \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        # \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        # \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        current = set()\n        next_level = set()\n        visited = set()  # \u5224\u91cd\n        father = {}  # DAG\n        level = -1  # \u5c42\u6b21\n\n        def stateIsValid(s):\n            return s in wordList or s == endWord\n\n        def stateIsTarget(s):\n            return s == endWord\n\n        def stateExtend(s):\n            result = set()\n            array = list(s)\n            for i in range(len(array)):\n                old = array[i]\n                for c in range(ord('a'), ord('z') + 1):\n                    # \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if chr(c) == array[i]:\n                        continue\n\n                    array[i] = chr(c)\n                    new_state = ''.join(array)\n\n                    if stateIsValid(new_state) and new_state not in visited:\n                        result.add(new_state)\n                    array[i] = old  # \u6062\u590d\u8be5\u5355\u8bcd\n            return result\n\n        result = []\n        current.add(beginWord)\n        while current:\n            level += 1\n            # \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            # \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if result and level + 1 > len(result[0]):\n                break\n\n            # 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            # 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            # \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            visited.update(current)\n\n            for state in current:\n                if stateIsTarget(state):\n                    path = []\n                    self.genPath(father, beginWord, state, path, result)\n                    continue\n                # \u6269\u5c55\u8282\u70b9\n                new_states = stateExtend(state)\n                for new_state in new_states:\n                    next_level.add(new_state)\n                    if new_state not in father:\n                        father[new_state] = []\n                    father[new_state].append(state)\n\n            current.clear()\n            # swap\n            current, next_level = next_level, current\n\n        return result\n\n    def genPath(self, father, start, state, path, result):\n        path.append(state)\n        if state == start:\n            if result:\n                if len(path) < len(result[0]):\n                    result.clear()\n                elif len(path) == len(result[0]):\n                    pass\n                else:\n                    raise ValueError(\"not possible to get here\")\n            tmp = path[::-1]\n            result.append(tmp)\n        else:\n            for f in father[state]:\n                self.genPath(father, start, f, path, result)\n        path.pop()\n"})})})]}),"\n",(0,s.jsx)(t.h3,{id:"\u56fe\u7684\u5e7f\u641c",children:"\u56fe\u7684\u5e7f\u641c"}),"\n",(0,s.jsxs)(t.p,{children:["\u524d\u9762\u7684\u89e3\u6cd5\uff0c\u5728\u72b6\u6001\u6269\u5c55\u7684\u65f6\u5019\uff0c\u6bcf\u6b21\u90fd\u662f\u4ece'a'\u5230'z'\u5168\u90e8\u679a\u4e3e\u4e00\u904d\uff0c\u91cd\u590d\u8ba1\u7b97\uff0c\u6bd4\u8f83\u6d6a\u8d39\uff0c\u5176\u5b9e\u5f53\u7ed9\u5b9a\u5b57\u5178",(0,s.jsx)(t.code,{children:"dict"}),"\u540e\uff0c\u5355\u8bcd\u4e0e\u5355\u8bcd\u4e4b\u95f4\u7684\u8def\u5f84\u5c31\u56fa\u5b9a\u4e0b\u6765\u4e86\uff0c\u672c\u8d28\u4e0a\u5355\u8bcd\u4e0e\u5355\u8bcd\u4e4b\u95f4\u6784\u6210\u4e86\u4e00\u4e2a\u65e0\u5411\u56fe\u3002\u5982\u679c\u4e8b\u5148\u628a\u8fd9\u4e2a\u56fe\u6784\u5efa\u51fa\u6765\uff0c\u90a3\u4e48\u72b6\u6001\u6269\u5c55\u5c31\u4f1a\u5927\u5927\u52a0\u5feb\u3002"]}),"\n",(0,s.jsxs)(i.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],children:[(0,s.jsx)(l.A,{value:"java",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"import java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Function;\n\n// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        Queue<String> q = new LinkedList<>();\n        HashMap<String, Integer> visited = new HashMap<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n        // only used by stateExtend()\n        final HashMap<String, HashSet<String>> g = buildGraph(wordList);\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, List<String> > stateExtend = (String s) -> {\n            List<String> result = new ArrayList<>();\n            final int newDepth = visited.get(s) + 1;\n            HashSet<String> list = g.get(s);\n            if (list == null) return result;\n\n            for (String newState : list) {\n                if (stateIsValid.apply(newState)) {\n                    if (visited.containsKey(newState)) {\n                        final int depth = visited.get(newState);\n                        if (depth < newDepth) {\n                            // do nothing\n                        } else if (depth == newDepth) {\n                            result.add(newState);\n                        } else {\n                            throw new IllegalStateException(\"not possible to get here\");\n                        }\n\n                    } else {\n                        result.add(newState);\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        q.offer(beginWord);\n        visited.put(beginWord, 0);\n        while (!q.isEmpty()) {\n            String state = q.poll();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && (visited.get(state) + 1) > result.get(0).size()) break;\n\n            if (stateIsTarget.apply(state)) {\n                ArrayList<String> path = new ArrayList<>();\n                genPath(father, beginWord, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            List<String> newStates = stateExtend.apply(state);\n            for (String newState : newStates) {\n                if (!visited.containsKey(newState)) {\n                    q.offer(newState);\n                    visited.put(newState, visited.get(state)+1);\n                }\n                ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                parents.add(state);\n                father.put(newState, parents);\n            }\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n\n    private static HashMap<String, HashSet<String>> buildGraph(Set<String> dict) {\n        HashMap<String, HashSet<String>> adjacency_list = new HashMap<>();\n        for (String word: dict) {\n            char[] array = word.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newWord = new String(array);\n\n                    if (dict.contains(newWord)) {\n                        HashSet<String> list = adjacency_list.getOrDefault(\n                                word, new HashSet<>());\n                        list.add(newWord);\n                        adjacency_list.put(word, list);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n        }\n        return adjacency_list;\n    }\n}\n"})})}),(0,s.jsx)(l.A,{value:"cpp",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n        const string& end, const unordered_set<string> &dict) {\n        queue<string> q;\n        unordered_map<string, int> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n        // only used by state_extend()\n        const unordered_map<string, unordered_set<string> >& g = build_graph(dict);\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end; };\n        auto state_extend = [&](const string &s) {\n            vector<string> result;\n            const int new_depth = visited[s] + 1;\n            auto iter = g.find(s);\n            if (iter == g.end()) return result;\n            const auto& list = iter->second;\n\n            for (const auto& new_state : list) {\n                if (state_is_valid(new_state)) {\n                    auto visited_iter = visited.find(new_state);\n                    if (visited_iter != visited.end()) {\n                        const int depth = visited_iter->second;\n                        if (depth < new_depth) {\n                            // do nothing\n                        }\n                        else if (depth == new_depth) {\n                            result.push_back(new_state);\n                        } else { // not possible\n                            throw std::logic_error(\"not possible to get here\");\n                        }\n                    }\n                    else {\n                        result.push_back(new_state);\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string>> result;\n        q.push(start);\n        visited[start] = 0;\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && visited[state] + 1 > result[0].size()) break;\n\n            if (state_is_target(state)) {\n                vector<string> path;\n                gen_path(father, start, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                if (visited.find(new_state) == visited.end()) {\n                    q.push(new_state);\n                    visited[new_state] = visited[state] + 1;\n                }\n                father[new_state].push_back(state);\n            }\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n        const string &start, const string &state, vector<string> &path,\n        vector<vector<string> > &result) {\n        path.push_back(state);\n        if (state == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                }\n                else if (path.size() == result[0].size()) {\n                    // do nothing\n                }\n                else { // not possible\n                    throw std::logic_error(\"not possible to get here \");\n                }\n            }\n            result.push_back(path);\n            reverse(result.back().begin(), result.back().end());\n        }\n        else {\n            for (const auto& f : father[state]) {\n                gen_path(father, start, f, path, result);\n            }\n        }\n        path.pop_back();\n    }\n    unordered_map<string, unordered_set<string> > build_graph(\n        const unordered_set<string>& dict) {\n        unordered_map<string, unordered_set<string> > adjacency_list;\n\n        for (const auto& word : dict) {\n            for (size_t i = 0; i < word.size(); ++i) {\n                string new_word(word);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if ((dict.find(new_word) != dict.end())) {\n                        auto iter = adjacency_list.find(word);\n                        if (iter != adjacency_list.end()) {\n                            iter->second.insert(new_word);\n                        }\n                        else {\n                            adjacency_list.insert(pair<string,\n                                unordered_set<string >> (word, unordered_set<string>()));\n                            adjacency_list[word].insert(new_word);\n                        }\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n        }\n        return adjacency_list;\n    }\n};\n"})})}),(0,s.jsx)(l.A,{value:"python",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from collections import defaultdict, deque\n\n# Word Ladder II\n# \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: set[str]) -> list[list[str]]:\n        q = deque()\n        visited = {}  # \u5224\u91cd\n        father = {}  # DAG\n        # only used by stateExtend()\n        g = self.buildGraph(wordList)\n\n        def stateIsValid(s):\n            return s in wordList or s == endWord\n\n        def stateIsTarget(s):\n            return s == endWord\n\n        def stateExtend(s):\n            result = []\n            newDepth = visited[s] + 1\n            if s not in g:\n                return result\n\n            for newState in g[s]:\n                if stateIsValid(newState):\n                    if newState in visited:\n                        depth = visited[newState]\n                        if depth < newDepth:\n                            # do nothing\n                            pass\n                        elif depth == newDepth:\n                            result.append(newState)\n                        else:\n                            raise ValueError("not possible to get here")\n                    else:\n                        result.append(newState)\n            return result\n\n        result = []\n        q.append(beginWord)\n        visited[beginWord] = 0\n        while q:\n            state = q.popleft()\n\n            # \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            # \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if result and (visited[state] + 1) > len(result[0]):\n                break\n\n            if stateIsTarget(state):\n                path = []\n                self.genPath(father, beginWord, state, path, result)\n                continue\n            # \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            # \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            # visited.insert(state)\n\n            # \u6269\u5c55\u8282\u70b9\n            newStates = stateExtend(state)\n            for newState in newStates:\n                if newState not in visited:\n                    q.append(newState)\n                    visited[newState] = visited[state] + 1\n                if newState not in father:\n                    father[newState] = []\n                father[newState].append(state)\n        return result\n\n    def genPath(self, father, start, state, path, result):\n        path.append(state)\n        if state == start:\n            if result:\n                if len(path) < len(result[0]):\n                    result.clear()\n                elif len(path) == len(result[0]):\n                    # do nothing\n                    pass\n                else:\n                    raise ValueError("not possible to get here")\n            tmp = path[::-1]\n            result.append(tmp)\n        else:\n            for f in father[state]:\n                self.genPath(father, start, f, path, result)\n        path.pop()\n\n    def buildGraph(self, dict_words):\n        adjacency_list = defaultdict(set)\n        for word in dict_words:\n            array = list(word)\n            for i in range(len(array)):\n                old = array[i]\n                for c in range(ord(\'a\'), ord(\'z\') + 1):\n                    # \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if chr(c) == array[i]:\n                        continue\n                    array[i] = chr(c)\n                    newWord = "".join(array)\n                    if newWord in dict_words:\n                        adjacency_list[word].add(newWord)\n                    array[i] = old  # \u6062\u590d\u8be5\u5355\u8bcd\n        return adjacency_list\n'})})})]}),"\n",(0,s.jsx)(t.h3,{id:"\u76f8\u5173\u9898\u76ee",children:"\u76f8\u5173\u9898\u76ee"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/en/bfs/graph/word-ladder",children:"Word Ladder"})}),"\n"]})]})}function p(n={}){const{wrapper:t}={...(0,a.R)(),...n.components};return t?(0,s.jsx)(t,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}},19365:(n,t,e)=>{e.d(t,{A:()=>i});e(96540);var r=e(34164);const s={tabItem:"tabItem_Ymn6"};var a=e(74848);function i(n){let{children:t,hidden:e,className:i}=n;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,i),hidden:e,children:t})}},11470:(n,t,e)=>{e.d(t,{A:()=>m});var r=e(96540),s=e(34164),a=e(23104),i=e(56347),l=e(205),d=e(57485),o=e(31682),u=e(70679);function c(n){return r.Children.toArray(n).filter((n=>"\n"!==n)).map((n=>{if(!n||(0,r.isValidElement)(n)&&function(n){const{props:t}=n;return!!t&&"object"==typeof t&&"value"in t}(n))return n;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof n.type?n.type:n.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(n){const{values:t,children:e}=n;return(0,r.useMemo)((()=>{const n=t??function(n){return c(n).map((n=>{let{props:{value:t,label:e,attributes:r,default:s}}=n;return{value:t,label:e,attributes:r,default:s}}))}(e);return function(n){const t=(0,o.XI)(n,((n,t)=>n.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((n=>n.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(n),n}),[t,e])}function p(n){let{value:t,tabValues:e}=n;return e.some((n=>n.value===t))}function f(n){let{queryString:t=!1,groupId:e}=n;const s=(0,i.W6)(),a=function(n){let{queryString:t=!1,groupId:e}=n;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:t,groupId:e});return[(0,d.aZ)(a),(0,r.useCallback)((n=>{if(!a)return;const t=new URLSearchParams(s.location.search);t.set(a,n),s.replace({...s.location,search:t.toString()})}),[a,s])]}function g(n){const{defaultValue:t,queryString:e=!1,groupId:s}=n,a=h(n),[i,d]=(0,r.useState)((()=>function(n){let{defaultValue:t,tabValues:e}=n;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${e.map((n=>n.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=e.find((n=>n.default))??e[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:a}))),[o,c]=f({queryString:e,groupId:s}),[g,w]=function(n){let{groupId:t}=n;const e=function(n){return n?`docusaurus.tab.${n}`:null}(t),[s,a]=(0,u.Dv)(e);return[s,(0,r.useCallback)((n=>{e&&a.set(n)}),[e,a])]}({groupId:s}),v=(()=>{const n=o??g;return p({value:n,tabValues:a})?n:null})();(0,l.A)((()=>{v&&d(v)}),[v]);return{selectedValue:i,selectValue:(0,r.useCallback)((n=>{if(!p({value:n,tabValues:a}))throw new Error(`Can't select invalid tab value=${n}`);d(n),c(n),w(n)}),[c,w,a]),tabValues:a}}var w=e(92303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var S=e(74848);function _(n){let{className:t,block:e,selectedValue:r,selectValue:i,tabValues:l}=n;const d=[],{blockElementScrollPositionUntilNextRender:o}=(0,a.a_)(),u=n=>{const t=n.currentTarget,e=d.indexOf(t),s=l[e].value;s!==r&&(o(t),i(s))},c=n=>{let t=null;switch(n.key){case"Enter":u(n);break;case"ArrowRight":{const e=d.indexOf(n.currentTarget)+1;t=d[e]??d[0];break}case"ArrowLeft":{const e=d.indexOf(n.currentTarget)-1;t=d[e]??d[d.length-1];break}}t?.focus()};return(0,S.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":e},t),children:l.map((n=>{let{value:t,label:e,attributes:a}=n;return(0,S.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:n=>d.push(n),onKeyDown:c,onClick:u,...a,className:(0,s.A)("tabs__item",v.tabItem,a?.className,{"tabs__item--active":r===t}),children:e??t},t)}))})}function b(n){let{lazy:t,children:e,selectedValue:a}=n;const i=(Array.isArray(e)?e:[e]).filter(Boolean);if(t){const n=i.find((n=>n.props.value===a));return n?(0,r.cloneElement)(n,{className:(0,s.A)("margin-top--md",n.props.className)}):null}return(0,S.jsx)("div",{className:"margin-top--md",children:i.map(((n,t)=>(0,r.cloneElement)(n,{key:t,hidden:n.props.value!==a})))})}function y(n){const t=g(n);return(0,S.jsxs)("div",{className:(0,s.A)("tabs-container",v.tabList),children:[(0,S.jsx)(_,{...t,...n}),(0,S.jsx)(b,{...t,...n})]})}function m(n){const t=(0,w.A)();return(0,S.jsx)(y,{...n,children:c(n.children)},String(t))}},28453:(n,t,e)=>{e.d(t,{R:()=>i,x:()=>l});var r=e(96540);const s={},a=r.createContext(s);function i(n){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function l(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),r.createElement(a.Provider,{value:t},n.children)}}}]);